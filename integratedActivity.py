"""
@authors: Aracelli Melissa Boza Zabarburú A01662934, Adolfo Hernández Fernández A01664412, Luis Enrique Salazar Pérez A00833460
@date: 30/09/2024
@description: Integrated Activity 1, pattern search for malicious pattern recognition, palindromic substring detection and largest common substring search
"""

def readFile(fileName):
    with open(fileName, mode="r") as file:
        arr = []
        lines = file.readlines()
        for element in lines[0]:
            arr.append(element)
        return arr

transmission1 = readFile("transmission1.txt")
transmission2 = readFile("transmission2.txt")
mcode1 = readFile("mcode1.txt")
mcode2 = readFile("mcode2.txt")
mcode3 = readFile("mcode3.txt")


"""
@description: Code for malicious pattern detection using KMP algorithm
"""

class Solution:
    def strStr(self, transmission: str, code: str) -> int:
        """KMP implementation to find if the malicious code exists in the transmission"""
        if code == "":
            return 0

        # Step 1: Preprocess the code to generate the LPS array
        lps = [0] * len(code)
        prevLPS, i = 0, 1
        while i < len(code):
            if code[i] == code[prevLPS]:
                lps[i] = prevLPS + 1
                prevLPS += 1
                i += 1
            elif prevLPS == 0:
                lps[i] = 0
                i += 1
            else:
                prevLPS = lps[prevLPS - 1]

        # Step 2: Search the code in the transmission using the LPS array
        i = 0  # Pointer for transmission
        j = 0  # Pointer for code
        while i < len(transmission):
            if transmission[i] == code[j]:
                i += 1
                j += 1
            else:
                if j == 0:
                    i += 1
                else:
                    j = lps[j - 1]

            if j == len(code):  # Full code match
                return i - len(code)  # Return the starting index of the code in transmission

        return -1  # If not found

def check_code_in_transmission(transmission, malicious_code):
    """Checks if the malicious code is in the transmission using KMP algorithm."""
    solution = Solution()
    position = solution.strStr(transmission, malicious_code)

    if position != -1:
        return f"true {position + 1}"  # Return 1-based index
    return "false"

# Part 1: Verifying if mcode files are contained in transmision files using KMP
print(check_code_in_transmission(transmission1, mcode1))  
print(check_code_in_transmission(transmission1, mcode2)) 
print(check_code_in_transmission(transmission1, mcode3))  
print(check_code_in_transmission(transmission2, mcode1))  
print(check_code_in_transmission(transmission2, mcode2))  
print(check_code_in_transmission(transmission2, mcode3))  


"""
Process a string using manachers algorithm to find LPS (Longest Palindromic Substring)
@param: text - string to be processed
@return:
    - start (int): The starting index of the LPS.
    - end (int): The ending index of the LPS.
    - maxLPSLength (int): The length of the LPS.
	
@credits: logic and pseudocode obtained from geeks for geeks
"""
def findLongestPalindromicSubstring(text): 
	textLength = len(text) 
	if textLength == 0: 
		return
	textLength = 2*textLength+1 # Position count 
	L = [0] * textLength # initialize array that contains info of palidnrome length
	L[0] = 0
	L[1] = 1
	C = 1	 # centerPosition 
	R = 2	 # centerRightPosition 
	i = 0 # currentRightPosition 
	iMirror = 0	 # currentLeftPosition 
	maxLPSLength = 0
	maxLPSCenterPosition = 0
	start = -1
	end = -1
	diff = -1

	for i in range(2,textLength): 
	
		# get currentLeftPosition iMirror for currentRightPosition i 
		iMirror = 2*C-i 
		L[i] = 0
		diff = R - i 
		# If currentRightPosition i is within centerRightPosition R 
		if diff > 0: 
			L[i] = min(L[iMirror], diff) 

		# Attempt to expand palindrome centered at currentRightPosition i 
		# Here for odd positions, we compare characters and 
		# if match then increment LPS Length by ONE 
		# If even position, we just increment LPS by ONE without 
		# any character comparison 
		try: 
			while ((i+L[i]) < textLength and (i-L[i]) > 0) and (((i+L[i]+1) % 2 == 0) or (text[(i+L[i]+1)//2] == text[(i-L[i]-1)//2])): 
				L[i]+=1
		except Exception as e: 
			pass

		if L[i] > maxLPSLength:	 # Update if required LPS
			maxLPSLength = L[i] 
			maxLPSCenterPosition = i 

		# If palindrome centered at currentRightPosition i 
		# expand beyond centerRightPosition R, 
		# adjust centerPosition C based on expanded palindrome. 
		if i + L[i] > R: 
			C = i 
			R = i + L[i] 

	start = (maxLPSCenterPosition - maxLPSLength) // 2
	end = start + maxLPSLength - 1
	return start, end, maxLPSLength
		
startT1, endT1, maxLPSLengthT1 = findLongestPalindromicSubstring(transmission1)
print (f"Longest palindromic substring of {maxLPSLengthT1} characters founded between " + str(startT1) + " and ", str(endT1), "characters of transmission 1") 

startT2, endT2, maxLPSLengthT2 = findLongestPalindromicSubstring(transmission2)
print (f"Longest palindromic substring of {maxLPSLengthT2} characters founded between " + str(startT2) + " and ", str(endT2), "characters of transmission 2") 
