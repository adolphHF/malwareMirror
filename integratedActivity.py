"""
@authors: Aracelli Melissa Boza Zabarburú A01662934, Adolfo Hernández Fernández A01664412, Luis Enrique Salazar Pérez A00833460
@date: 30/09/2024
@description: Integrated Activity 1, pattern search for malicious pattern recognition, palindromic substring detection and largest common substring search
"""

def readFile(fileName):
    with open(fileName, mode="r") as file:
        arr = []
        lines = file.readlines()
        for element in lines[0]:
            arr.append(element)
        return arr

transmission1 = readFile("transmission1.txt")
transmission2 = readFile("transmission2.txt")
mcode1 = readFile("mcode1.txt")
mcode2 = readFile("mcode2.txt")
mcode3 = readFile("mcode3.txt")

"""
Process a string using manachers algorithm to find LPS (Longest Palindromic Substring)
@param: text - string to be processed
@return:
    - start (int): The starting index of the LPS.
    - end (int): The ending index of the LPS.
    - maxLPSLength (int): The length of the LPS.
	
@credits: logic and pseudocode obtained from geeks for geeks
"""
def findLongestPalindromicSubstring(text): 
	textLength = len(text) 
	if textLength == 0: 
		return
	textLength = 2*textLength+1 # Position count 
	L = [0] * textLength # initialize array that contains info of palidnrome length
	L[0] = 0
	L[1] = 1
	C = 1	 # centerPosition 
	R = 2	 # centerRightPosition 
	i = 0 # currentRightPosition 
	iMirror = 0	 # currentLeftPosition 
	maxLPSLength = 0
	maxLPSCenterPosition = 0
	start = -1
	end = -1
	diff = -1

	for i in range(2,textLength): 
	
		# get currentLeftPosition iMirror for currentRightPosition i 
		iMirror = 2*C-i 
		L[i] = 0
		diff = R - i 
		# If currentRightPosition i is within centerRightPosition R 
		if diff > 0: 
			L[i] = min(L[iMirror], diff) 

		# Attempt to expand palindrome centered at currentRightPosition i 
		# Here for odd positions, we compare characters and 
		# if match then increment LPS Length by ONE 
		# If even position, we just increment LPS by ONE without 
		# any character comparison 
		try: 
			while ((i+L[i]) < textLength and (i-L[i]) > 0) and (((i+L[i]+1) % 2 == 0) or (text[(i+L[i]+1)//2] == text[(i-L[i]-1)//2])): 
				L[i]+=1
		except Exception as e: 
			pass

		if L[i] > maxLPSLength:	 # Update if required LPS
			maxLPSLength = L[i] 
			maxLPSCenterPosition = i 

		# If palindrome centered at currentRightPosition i 
		# expand beyond centerRightPosition R, 
		# adjust centerPosition C based on expanded palindrome. 
		if i + L[i] > R: 
			C = i 
			R = i + L[i] 

	start = (maxLPSCenterPosition - maxLPSLength) // 2
	end = start + maxLPSLength - 1
	return start, end, maxLPSLength
		
startT1, endT1, maxLPSLengthT1 = findLongestPalindromicSubstring(transmission1)
print (f"Longest palindromic substring of {maxLPSLengthT1} characters founded between " + str(startT1) + " and ", str(endT1), "characters of transmission 1") 

startT2, endT2, maxLPSLengthT2 = findLongestPalindromicSubstring(transmission2)
print (f"Longest palindromic substring of {maxLPSLengthT2} characters founded between " + str(startT2) + " and ", str(endT2), "characters of transmission 2") 
