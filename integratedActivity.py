"""
@authors: Aracelli Melissa Boza Zabarburú A01662934, Adolfo Hernández Fernández A01664412, Luis Enrique Salazar Pérez A00833460
@date: 30/09/2024
@description: Integrated Activity 1, pattern search for malicious pattern recognition, palindromic substring detection and largest common substring search
"""

def readFile(fileName):
    with open(fileName, mode="r") as file:
        lines = file.readlines()
        return lines[0]

transmission1 = readFile("transmission1.txt")
transmission2 = readFile("transmission2.txt")
mcode1 = readFile("mcode1.txt")
mcode2 = readFile("mcode2.txt")
mcode3 = readFile("mcode3.txt")

"""
@description: Code for malicious pattern detection using KMP algorithm
"""

class Solution:
    def strStr(self, transmission: str, code: str) -> int:
        """KMP implementation to find if the malicious code exists in the transmission"""
        if code == "":
            return 0

        # Step 1: Preprocess the code to generate the LPS array
        lps = [0] * len(code)
        prevLPS, i = 0, 1
        while i < len(code):
            if code[i] == code[prevLPS]:
                lps[i] = prevLPS + 1
                prevLPS += 1
                i += 1
            elif prevLPS == 0:
                lps[i] = 0
                i += 1
            else:
                prevLPS = lps[prevLPS - 1]

        # Step 2: Search the code in the transmission using the LPS array
        i = 0  # Pointer for transmission
        j = 0  # Pointer for code
        while i < len(transmission):
            if transmission[i] == code[j]:
                i += 1
                j += 1
            else:
                if j == 0:
                    i += 1
                else:
                    j = lps[j - 1]

            if j == len(code):  # Full code match
                return i - len(code)  # Return the starting index of the code in transmission

        return -1  # If not found

def check_code_in_transmission(transmission, malicious_code):
    """Checks if the malicious code is in the transmission using KMP algorithm."""
    solution = Solution()
    position = solution.strStr(transmission, malicious_code)

    if position != -1:
        return f"true {position + 1}"  # Return 1-based index
    return "false"

# Part 1: Verifying if mcode files are contained in transmision files using KMP
print(check_code_in_transmission(transmission1, mcode1))  
print(check_code_in_transmission(transmission1, mcode2)) 
print(check_code_in_transmission(transmission1, mcode3))  
print(check_code_in_transmission(transmission2, mcode1))  
print(check_code_in_transmission(transmission2, mcode2))  
print(check_code_in_transmission(transmission2, mcode3))  


"""
Process a string using manachers algorithm to find LPS (Longest Palindromic Substring)
@param: text - string to be processed
@return:
    - start (int): The starting index of the LPS.
    - end (int): The ending index of the LPS.
    - maxLPSLength (int): The length of the LPS.
	
@credits: logic and pseudocode obtained from geeks for geeks
"""
def findLongestPalindromicSubstring(text): 
	textLength = len(text) 
	if textLength == 0: 
		return
	textLength = 2*textLength+1 # Position count 
	L = [0] * textLength # initialize array that contains info of palidnrome length
	L[0] = 0
	L[1] = 1
	C = 1	 # centerPosition 
	R = 2	 # centerRightPosition 
	i = 0 # currentRightPosition 
	iMirror = 0	 # currentLeftPosition 
	maxLPSLength = 0
	maxLPSCenterPosition = 0
	start = -1
	end = -1
	diff = -1

	for i in range(2,textLength): 
	
		# get currentLeftPosition iMirror for currentRightPosition i 
		iMirror = 2*C-i 
		L[i] = 0
		diff = R - i 
		# If currentRightPosition i is within centerRightPosition R 
		if diff > 0: 
			L[i] = min(L[iMirror], diff) 

		# Attempt to expand palindrome centered at currentRightPosition i 
		# Here for odd positions, we compare characters and 
		# if match then increment LPS Length by ONE 
		# If even position, we just increment LPS by ONE without 
		# any character comparison 
		try: 
			while ((i+L[i]) < textLength and (i-L[i]) > 0) and (((i+L[i]+1) % 2 == 0) or (text[(i+L[i]+1)//2] == text[(i-L[i]-1)//2])): 
				L[i]+=1
		except Exception as e: 
			pass

		if L[i] > maxLPSLength:	 # Update if required LPS
			maxLPSLength = L[i] 
			maxLPSCenterPosition = i 

		# If palindrome centered at currentRightPosition i 
		# expand beyond centerRightPosition R, 
		# adjust centerPosition C based on expanded palindrome. 
		if i + L[i] > R: 
			C = i 
			R = i + L[i] 

	start = (maxLPSCenterPosition - maxLPSLength) // 2
	end = start + maxLPSLength - 1
	return start, end, maxLPSLength
		
startT1, endT1, maxLPSLengthT1 = findLongestPalindromicSubstring(transmission1)
print (f"Longest palindromic substring of {maxLPSLengthT1} characters founded between " + str(startT1) + " and " + str(endT1) + " characters of transmission 1") 

startT2, endT2, maxLPSLengthT2 = findLongestPalindromicSubstring(transmission2)
print (f"Longest palindromic substring of {maxLPSLengthT2} characters founded between " + str(startT2) + " and " + str(endT2) + " characters of transmission 2")

"""
Process a string using suffix array algorithm to find LCP (Longest Common Substring)
@param:
    - transmission1 (str): First string to be processed
    - transmission2 (str): Second string to be processed
@return:
    - start (int): The starting index of the LCP in transmission1
    - end (int): The ending index of the LCP in transmission1
    - longest_substring (str): Longest common substring found in both inputs
	
@credits: logic and pseudocode obtained from geeks for geeks
"""

# Class to store information of a suffix
class suffix:
    def __init__(self):
        self.index = 0
        self.rank = [0, 0]

# Function to build and return the suffix array for a given string
def buildSuffixArray(txt, n):
    suffixes = [suffix() for _ in range(n)]
    for i in range(n):
        suffixes[i].index = i
        suffixes[i].rank[0] = (ord(txt[i]) - ord("a"))
        suffixes[i].rank[1] = (ord(txt[i + 1]) - ord("a")) if (i + 1) < n else -1

    suffixes = sorted(suffixes, key=lambda x: (x.rank[0], x.rank[1]))

    ind = [0] * n
    k = 4
    while k < 2 * n:
        rank = 0
        prev_rank = suffixes[0].rank[0]
        suffixes[0].rank[0] = rank
        ind[suffixes[0].index] = 0

        for i in range(1, n):
            if (suffixes[i].rank[0] == prev_rank and
                suffixes[i].rank[1] == suffixes[i - 1].rank[1]):
                prev_rank = suffixes[i].rank[0]
                suffixes[i].rank[0] = rank
            else:
                prev_rank = suffixes[i].rank[0]
                rank += 1
                suffixes[i].rank[0] = rank
            ind[suffixes[i].index] = i

        for i in range(n):
            nextindex = suffixes[i].index + k // 2
            suffixes[i].rank[1] = suffixes[ind[nextindex]].rank[0] if (nextindex < n) else -1

        suffixes = sorted(suffixes, key=lambda x: (x.rank[0], x.rank[1]))
        k *= 2

    suffixArr = [0] * n
    for i in range(n):
        suffixArr[i] = suffixes[i].index

    return suffixArr

# Function to build the LCP array
def buildLCP(txt, suffixArr, n):
    rank = [0] * n
    lcp = [0] * n

    for i in range(n):
        rank[suffixArr[i]] = i

    h = 0
    for i in range(n):
        if rank[i] > 0:
            j = suffixArr[rank[i] - 1]
            while (i + h < n) and (j + h < n) and (txt[i + h] == txt[j + h]):
                h += 1
            lcp[rank[i]] = h
            if h > 0:
                h -= 1
    return lcp

# Function to find the longest common substring between s1 and s2
def longest_common_substring(s1, s2):
    # Combine the strings with a separator
    combined_txt = s1 + '$' + s2
    n = len(combined_txt)

    # Build the suffix array and LCP array
    suffixArr = buildSuffixArray(combined_txt, n)
    lcp = buildLCP(combined_txt, suffixArr, n)

    max_len = 0
    start_index = -1

    # Traverse the LCP array to find the maximum LCP between suffixes of s1 and s2
    len_s1 = len(s1)
    for i in range(1, n):
        # Check if the suffixes come from different strings (one from s1, one from s2)
        if (suffixArr[i] < len_s1) != (suffixArr[i - 1] < len_s1):
            if lcp[i] > max_len:
                max_len = lcp[i]
                start_index = suffixArr[i] if suffixArr[i] < len_s1 else suffixArr[i - 1]

    # If no common substring was found
    if max_len == 0:
        return None, None, ""

    # Return starting, ending positions (1-indexed), and the longest substring
    return start_index + 1, start_index + max_len, combined_txt[start_index:start_index + max_len]

start, end, longest_substring = longest_common_substring(transmission1, transmission2)

if longest_substring:
    print(f"Longest common substring: {longest_substring}")
    print(f"Start position: {start}")
    print(f"End position: {end}")
else:
    print("No common substring found.")




